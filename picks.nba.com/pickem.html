<!-- 1.0.20 --><!DOCTYPE html><html lang="en">
<!-- Mirrored from picks.nba.com/pickem by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 09 Feb 2026 09:22:17 GMT -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta property="og:type" content="website"><meta property="twitter:card" content="summary"><style>a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,main,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section{display:block}[hidden]{display:none}body{line-height:1}menu,ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:'';content:none}table{border-collapse:collapse;border-spacing:0}</style><link href="https://cdn-us.monterosa.cloud/assets/5f/5f4f2112-5c5a-46fe-8478-1f1a234b50d7/orig" rel="icon" type="image/png"><title>NBA Pick'Em | Play for Free Every Day</title><meta property="og:title" content="Come Play NBA Pick'Em with Me!"><meta property="twitter:title" content="NBA Pick'Em | Play for Free Every Day"><meta itemprop="name" content="NBA Pick'Em | Play for Free Every Day"><meta property="description" content="Play Pick'Em for free every day. Predict player stat lines, team props, and more to win great prizes."><meta property="og:description" content="Who will score more points tonight? Lock in your daily predictions now."><meta property="twitter:description" content="Play Pick'Em for free every day. Predict player stat lines, team props, and more to win great prizes."><meta itemprop="description" content="Play Pick'Em for free every day. Predict player stat lines, team props, and more to win great prizes."><meta property="og:image" content="https://cdn-us.monterosa.cloud/assets/0b/0bae0b5c-0d9c-4f91-83f8-a76c762981b5/orig"><meta property="twitter:image" content="https://cdn-dev.monterosa.cloud/assets/c0/c0fb6f4e-53fa-4ec6-a219-638a77760884/orig"><meta itemprop="image" content="https://cdn-dev.monterosa.cloud/assets/c0/c0fb6f4e-53fa-4ec6-a219-638a77760884/orig"><link rel="preconnect" href="https://fonts.googleapis.com/"><link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin><link rel="preconnect" href="https://cdn.monterosa.cloud/"><link rel="preload" href="https://cdn.monterosa.cloud/config/enmasse.json" as="fetch" crossorigin><link rel="preconnect" href="https://edgeservers-europe.monterosa.cloud/"><link rel="preconnect" href="https://static-datacapture-europe.monterosa.cloud/"><script defer="defer" src="../code.jquery.com/jquery-3.6.0.min.js"></script><script async src="../www.googletagservices.com/tag/js/f.txt"></script><script>window.__ENV__ = {
        GLOBAL_LVIS_PROJECT_ID: ""
      };</script><style>html, body {
        background-color: #000;
      }</style><script defer="defer" src="nba-pickem/1.0.20/6736.1e5a3e1160eed8b7e9b1.js"></script><script defer="defer" src="nba-pickem/1.0.20/main.86c611ce48c55e14be61.js"></script>
      <script src="../cdn.nba.com/user-consent/index.min.js"></script>
      <script>
        const config = {
        cookieDomain: '.nba.com',
        brand: 'NBA',
        src: 'https://cdn.cookielaw.org/scripttemplates/otSDKStub.js',
        domId: "d0494fd0-8921-497a-8323-e3d29775ce1b",
        countryCode: "PH",
      };
      if (window.WM) {
        window.WM.UserConsentConfig = config;
        window.WM.UserConsent.init(config);
      }
      </script><script>window.Afterburner={
  "projectId": "55d4649b-5d27-4ec7-b7bd-426c56f2276e",
  "staticHost": "cdn-us.monterosa.cloud",
  "country": "PH"
}</script><link rel="canonical" href="pickem.html"></head
      ><body ontouchstart=""><div id="loader"><div></div><div></div><div></div></div><noscript>Please enable JavaScript</noscript>
        <!-- Default Pageview Config Overrides  -->
        <script type="text/javascript">
          window.utag_cfg_ovrd = window.utag_cfg_ovrd || {};
          window.utag_cfg_ovrd.noview = true;
        </script>
        <!-- Loading script asynchronously -->
        <script type="text/javascript">
          (function(a,b,c,d){
            a='../tags.nba.com/nba-play/prod/utag.js';
            b=document;c='script';d=b.createElement(c);d.src=a;d.type='text/java'+c;d.async=true;
            a=b.getElementsByTagName(c)[0];a.parentNode.insertBefore(d,a);
          })();
        </script>
        <div id="app"
      ></div><div id="modal"></div></body><script>const searchParams = new URLSearchParams(window.location.search);
    const urlBg = searchParams.get("bg");
    const urlColor = searchParams.get("color");

    if(urlBg){document.documentElement.style.setProperty("--urlBackground", `#${urlBg}`)};
    if(urlColor){document.documentElement.style.setProperty("--urlColor", `#${urlColor}`)}</script><script async>(function () {
      // Store all WebSocket connections
      // FTP-1638 - Fix issue with Iphone not closing websocket connection when offline.
      const originalWebSocket = window.WebSocket;
      const webSockets = new Set();

      // WebSocket interceptor setup
      window.wsRecorder = {
        isRecording: false,
        listeners: new Set(),
        messages: [], // Add messages array to store recorded messages
        startRecording: function() {
          this.isRecording = true;
          this.messages = []; // Clear messages when starting new recording
        },
        stopRecording: function() {
          this.isRecording = false;
          this.messages = []; // Clear messages when stopping
          this.listeners.clear();
        },
        addMessage: function(message) {
          if (this.isRecording) {
            console.log('Recording message', message);
            const messageData = {
              timestamp: Date.now(),
              message: message
            };
            this.messages.push(messageData); // Store message      
            // // Notify all listeners
            this.listeners.forEach(listener => listener(messageData));
          }
        },
        addListener: function(listener) {
          this.listeners.add(listener);
          return () => this.listeners.delete(listener); // Return cleanup function
        },
        getMessages: function() {
          return this.messages;
        }
      };

      const queryProjectId = new URLSearchParams(window.location.search).get('p');
      const afterburnerProjectId = window?.Afterburner?.projectId || null;
      const envProjectId = window.__ENV__?.GLOBAL_LVIS_PROJECT_ID;
      const projectId = queryProjectId || afterburnerProjectId || envProjectId;
      
      window.WebSocket = function(...args) {
        const ws = new originalWebSocket(...args);
        webSockets.add(ws);

        // Store original send method
        const originalSend = ws.send;

        // Override send method to record outgoing messages and handle connection state
        ws.send = function(data) {
          // Upgrade auth message to version 13 by adding project id and the version
          if (typeof data === 'string' && data.includes('authr') && data.includes('|8|')) {
            data = data.replace('|8|', '|13|');
            //Add ad the end the project id
            data = data + '|||' + projectId;
          }

          if (ws.readyState === WebSocket.CONNECTING) {
            console.log('WebSocket is connecting, waiting...');
            return new Promise((resolve) => {
              const timeoutId = setTimeout(() => {
                cleanup();
                resolve();
              }, 4000);

              const onOpen = () => {
                cleanup();
                originalSend.apply(ws, arguments);
                resolve();
              };

              const onClose = () => {
                cleanup();
                resolve();
              };

              const cleanup = () => {
                clearTimeout(timeoutId);
                ws.removeEventListener('open', onOpen);
                ws.removeEventListener('close', onClose);
              };

              ws.addEventListener('open', onOpen);
              ws.addEventListener('close', onClose);
            });
          }

          try {
            const result = originalSend.apply(ws, arguments);
            return result;
          } catch (error) {
            console.error('Error sending message', error);
          }
        }

        // Store original event listeners
        const originalListeners = new Map();

        // Override addEventListener to capture all message listeners
        const originalAddEventListener = ws.addEventListener;
        ws.addEventListener = function(type, listener, options) {
          if (type === 'message') {
            // Create a message listener from the server.
            const wrappedListener = function(event) {
              const messageData = event.data;
              // Record v_ack messages if recording is enabled
              if (window.wsRecorder.isRecording && typeof messageData === 'string' && messageData.includes('v_ack')) {
                window.wsRecorder.addMessage(messageData);
              }
              // Call the original listener
              return listener.call(this, event);
            };

            originalListeners.set(listener, wrappedListener);
            originalAddEventListener.call(ws, type, wrappedListener, options);
          } else {
            originalAddEventListener.call(ws, type, listener, options);
          }
        };

        // Override onmessage property
        Object.defineProperty(ws, 'onmessage', {
          set: function(listener) {
            if (listener) {
              this.addEventListener('message', listener);
            }
          },
          get: function() {
            return null;
          }
        });

        ws.addEventListener('close', () => {
          webSockets.delete(ws);
        });

        return ws;
      };

      // Add an event listener for the 'offline' event
      window.addEventListener('offline', () => {
        // Close all WebSocket connections
        try {
          for (const ws of webSockets) {
            ws.close();
          }
        }
        catch (error) {
          console.log('error', error);
        }

        // Clear the set of WebSocket connections
        webSockets.clear();
      });
    })();</script>
<!-- Mirrored from picks.nba.com/pickem by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 09 Feb 2026 09:22:19 GMT -->
</html>